---
title: 【Java】JVM（中）
date: 2021-05-21
tags:
- Java
---
## 三、垃圾回收

### 如何判断对象可以回收

#### 引用计数法

判断对象被引用的次数，看对象是否可以被回收。但是根据下面的互相调用的情况，此时A、B两对象互相引用，且引用次数为1的话，则不能根据引用次数对其进行垃圾回收（因为互相引用），但是长时间不对这两者对象进行垃圾回收，则会导致内存泄漏，长时间存在内存得不到释放的情况，所以引用计数法存在一定的弊端。在实际的虚拟机中，一般需要采用下面的可达性分析算法。

![image-20210315221109421](https://gitee.com/realBeBetter/image/raw/master/img/x4g76VDOY8Cbsvy.png)

#### 可达性分析算法

在此算法中，我们将那些一定不能被垃圾回收的对象称之为“根对象”。在进行垃圾回收之前，会对类中所有的对象进行一次扫描，看看其中的对象是否会被其中的根对象直接或间接引用。如果有引用，则该对象不能被垃圾回收，由于根对象的绑定关系，会导致该对象有需要被引用的可能，故不能被垃圾回收；反之，如果对象没有被根对象直接或间接引用，则该对象存在被垃圾回收的可能性。

以上这个过程被称之为可达性分析算法。但是，如何确定根对象（GC Root）？

![image-20210315221925229](https://gitee.com/realBeBetter/image/raw/master/img/x4g76VDOY8Cbsvy.png)

要找到GC Root对象，我们需要借助一个Eclipse提供的工具——Memory Analyzer，简称MAT。

![image-20210315222123950](https://gitee.com/realBeBetter/image/raw/master/img/ONrVphmqjnRGwfQ.png)

具体操作步骤：

先找出Java程序的进程ID，之后输入相关参数，生成二进制文件，抓取程序进程快照，之后利用工具打开生成的二进制文件 进行分析。

![image-20210315222652264](https://gitee.com/realBeBetter/image/raw/master/img/N7stJQTXS6ozWnu.png)

MAT工具打开文件之后，操作界面如下所示：

![image-20210315222616032](https://gitee.com/realBeBetter/image/raw/master/img/JK5VOMjwTC3ZIFv.png)

GC Roots显示的界面如下所示：

![image-20210315222811764](https://gitee.com/realBeBetter/image/raw/master/img/JK5VOMjwTC3ZIFv.png)

可知当前一共有641个对象。其中，System Class为系统核心类，不能被回收掉。

实际上的分析，只需要看主线程中的对象，查看哪些本地变量是GC Root对象，不能被回收。

![image-20210315225047576](https://gitee.com/realBeBetter/image/raw/master/img/O1G9f4CSjPTrQwF.png)

#### 四种引用

实际上常用的一共有五种引用。分别为：强引用、弱引用、软引用、虚引用、终结器引用。

引用示例图：（其中，实线表示强引用）

![image-20210315225321919](https://gitee.com/realBeBetter/image/raw/master/img/UEYmOKGqhB9JRnd.png)

①只有当一个对象与其相连的所有强引用都断开，才能被垃圾回收。②当连接A2对象的强引用断开之后，若执行垃圾回收之后仍然发现内存不够用的时候，才会继续垃圾回收掉A2对象，也就是软引用的对象。③当指向A3对象的强引用断开之后，只要发生了垃圾回收，不管内存是都宽裕，A3（弱引用对象）都会被回收掉。④当软引用连接的对象（A2）被垃圾回收之后，软引用本身也已经成为了一个对象，这个时候会进入引用队列。同时，弱引用同理；二者在连接的对象被垃圾回收之后，都会进入引用队列。这是因为软引用和弱引用他们本身也需要占用一定的内存。如果想要对软引用和弱引用他们本身进行垃圾回收处理，可以借助引用队列找到他们，并做进一步的处理（遍历二者进行内存释放，相当于断开GC Root对象对他们的强引用，进行垃圾回收）。

**虚引用和终结器引用**

此两者必须配合引用队列使用。当虚引用引用的对象被垃圾回收之后，虚引用就会被放入引用队列，从而间接地用一个线程来调用虚引用的方法，使用 `unsafe.freeMemory()`来释放直接内存。

![image-20210316100614853](https://i.loli.net/2021/03/16/HjMinK8dYxQ6Nor.png)

终结器引用：所有的Java对象都继承自Object父类，Object父类有一个**finalize()**方法。当A4对象的强引用被断开之后，将终结器引用放入引用队列中，然后由一个 **优先级很低的线程去检查引用队列中是否存在终结器引用，如果存在终结器引用，则调用完A4的finalize方法，等调用结束，就可以等待下一次进行垃圾回收。**其中，终结器引用效率很低：第一次回收时还不能真正的将其回收，需要二次进行回收；其次，要将终结器引用进行入队操作；再者，检测终结器引用的线程优先级很低，被执行的机会很少，可能会导致连接的方法的**finalize**方法迟迟得不到调用，无法结束自身的生命周期，所以导致该对象（A4）存在的生命周期中一直占用内存，短期内得不到释放。所以一般不推荐使用**finalize**方法释放内存。

![image-20210316100953578](https://i.loli.net/2021/03/16/OLq16p3xkzEAXlZ.png)

#### 引用的特点

![image-20210316101816306](https://i.loli.net/2021/03/16/WUCtjGx9L3gvHTm.png)

**软引用（SoftReference）**

强引用和软引用的代码案例区别：其中，注释的部分即强引用；其余部分为软引用。

![image-20210316102126304](https://i.loli.net/2021/03/16/fDTb8KSasnEj37x.png)

![image-20210316102733574](https://i.loli.net/2021/03/16/jHnpJxeWwkTlIdX.png)

当软引用使用不到的时候，需要使用引用队列对软引用实现释放。使用**ReferenceQueue<E>**创建引用队列对象，对其进行软引用释放内存。其中，引用队列的泛型需要和软引用的泛型一致。之后，再使用软引用的时候还需要关联引用队列，在上述代码对应位置改成`new byte[_4MB], queue`，关联之后，当软引用引用的对象被引用之后，对象需要回收时，会将软引用本身也加入到queue中去。整个过程，代码示例如下：

![image-20210316103459904](https://i.loli.net/2021/03/16/CPB8NyQKRiDjnwT.png)

**弱引用（WeakReference）**

当弱引用连接的对象仅有弱引用时，垃圾回收时，无论内存是否充足，都会将弱引用所引用的对象进行垃圾回收。同样，也可以配合垃圾引用队列进行垃圾回收弱引用本身。

![image-20210316105520329](https://i.loli.net/2021/03/16/SAkicfyJdKWXpbD.png)

### 垃圾回收算法

#### 标记清除（Mark Sweep）

顾名思义，标记清楚就是标记和清除两个步骤。第一个步骤，先标记可以被垃圾回收的对象（或者说需要被垃圾回收的对象）。这个步骤的思路：沿着GC Root的对象，从头到尾遍历所有对象，连着GC Root的对象则为强引用，不可被垃圾回收，其余的则根据情况进行标记，等待下一个步骤——清除。第二个步骤，清除标记的对象，将所有被标记的、可以被回收的对象进行垃圾回收。

其中，实现的细节问题：清除的步骤不是将对象的每个字节进行清零操作，而是将对象占用内存的起始地址记录在一个**空闲的地址链表**中。下次分配新的对象时，可以直接从空闲的地址链表中找，如果有足够的地址空间容纳这个对象，则为该对象分配空闲的地址空间。

![image-20210316105732003](https://i.loli.net/2021/03/16/ozFrvGJBKRNC5Ln.png)

标记清除的优缺点：

优：标记清除的速度快，只需要对需要被垃圾回收的对象空间的起始地址做记录即可，所以标记清除的速度快。

缺：容易产生内存碎片。因为记录的是原对象的起始地址，原地址被标记记录之后，不会对地址空间进行整理，所以在对新对象进行地址分配的时候，容易造成内存的使用的不连续，导致大量空闲空间无法得到使用，造成内存使用的不充分不连贯。（页内碎片）

#### 标记整理（Mark Compact）

标记整理算法，相比于之前的标记清除算法，在第二个清除的步骤中，不只是简单的清除，而是将清除之后不连续的内存空间进行整理，最后使得余留下来的对象占据的还是连续的内存空间。

标记整理的优缺点：

优：相较于标记清除，不会产生内存碎片。

缺：由于涉及对象空间的移动，使得整个过程更加复杂繁琐。内存区块的拷贝移动、内存地址的改变等，这些问题更加复杂，需要更多的工作量，所以速度更慢。

![image-20210316111207763](https://i.loli.net/2021/03/16/jXkUfoZyl7NhxmY.png)

#### 复制（Copy）

复制算法，首先将GC Root的强引用对象赋值到TO区域中；其次，将FROM中的所有需要垃圾回收的对象进行垃圾回收；之后，交换FROM和TO的位置；最终，垃圾回收完成。演示步骤如下：

![image-20210316111722361](https://i.loli.net/2021/03/16/ORCBi9VuQA5KMaq.png)

![image-20210316111752713](https://i.loli.net/2021/03/16/AuH1TWz7viLPhrD.png)

![image-20210316111813417](https://i.loli.net/2021/03/16/c5vDVkXUW9jniNJ.png)

![image-20210316111841962](https://i.loli.net/2021/03/16/l8J7fW9tnjIzTSg.png)

复制算法的优缺点：

优：不会产生内存碎片，最终形成连贯的空闲空间。

缺：在进行垃圾回收的时候，会占用双倍的内存空间，且工作量也比较大。

#### 总结

**标记清除算法**（Mark Sweep）

- 速度较快
- 会造成内存碎片

![image-20210923221052461](https://gitee.com/realBeBetter/image/raw/master/img/image-20210923221052461.png)

**标记整理算法**（Mark Compact）

- 速度慢
- 没有内存碎片

![image-20210923221136091](https://gitee.com/realBeBetter/image/raw/master/img/image-20210923221136091.png)

**复制算法**（Copy）

- 不会有内存碎片
- 需要占用双倍内存空间

![image-20210923221219180](https://gitee.com/realBeBetter/image/raw/master/img/image-20210923221219180.png)

### 分代回收

垃圾回收中，有新生代、老年代、伊甸园（Eden）、幸存区（FROM）、幸存区（TO）的概念。

我们一般将需要长时间使用的对象放在老年代中，把那些用完即丢的对象放在新生代中。针对不同对象的生命周期，为他们制定不同的垃圾回收策略。这就是创造分代回收的原因。

首先，新生代的结构如下所示：

![image-20210316193626706](https://i.loli.net/2021/03/16/YKVk3cihRW4aHA6.png)

我们将每次新创建的对象存放在伊甸园中。但是，新生代中伊甸园的内存是有限的，当伊甸园的内存不够时，便会触发新生代的一次垃圾回收，回收处理伊甸园中的垃圾，此次垃圾回收称之为**Minor GC**。

![image-20210316193836146](https://i.loli.net/2021/03/16/LVvCZDRdKqtMiI6.png)

此次垃圾回收，利用复制算法，将幸存的对象放入幸村区TO中，并将这些对象的生命周期进行`+1`的操作，表示这些对象已经经历了一次垃圾回收，但是幸存下来，并没有被回收掉。然后根据复制算法，将`From`和`To`的位置交换，完成一次垃圾回收。

![image-20210316194208238](https://i.loli.net/2021/03/16/g7Sj9BARxh8Wnmu.png)

此时上图中被标记的对象就会被**Minor GC**回收掉。第二过程中，等到伊甸园中的对象再次内存不足时，就会再次出发Minor GC进行垃圾回收。但是，**此次Minor GC不光要扫描伊甸园中的对象，还需要对之前幸存区From中的对象进行扫描，看是否存在需要被垃圾回收的对象**。最终幸存的对象生命周期`+1`，放在幸存区From中。

![image-20210923220800244](https://gitee.com/realBeBetter/image/raw/master/img/image-20210923220800244.png)

在经历了第二轮的Minor GC之后，可能的对象存活情况如下：

![image-20210316194701454](https://i.loli.net/2021/03/16/my8FhtxCrVNekJR.png)

在经历多次Minor GC之后，可能存在一些对象的生命周期变得比较长（超过一定阈值），这个时候就出现了**晋升**——将这些生命周期较长的对象存放在老年代区（最大生命周期是15——4bit（1111））。因为老年代发生GC的频率相对新生代来说较低，所以生存周期更长的对象放在老年代区能够减少扫描的次数，提高一定的工作效率。

但是，当新生代的伊甸园以及From区、老年代区都无法存放下新生成的对象时，这个时候就会触发一次**Full GC**。

![image-20210316195135537](https://i.loli.net/2021/03/16/fOyjD4bp5RhmUTE.png)

分代垃圾回收的一些特点：

![image-20210923220518591](https://gitee.com/realBeBetter/image/raw/master/img/image-20210923220518591.png)

- 对象首先分配在伊甸园区域
- 新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加一并且交换from和to
- minor gc会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
- 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15 (4bit)
- 当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，STW的时间更长

#### 相关参数

![image-20210316200552034](https://i.loli.net/2021/03/16/ohkQJ7riRGCL5M1.png)

### 垃圾回收器

**三种垃圾回收器的特点**

- 串行
  - 单线程
  - 堆内存较小，适合个人电脑
- 吞吐量优先
  - 多线程
  - 堆内存较大，多核cpu
  - 让单位时间内，STW的时间最短
- 响应时间优先
  - 多线程
  - 堆内存较大，多核cpu
  - 尽可能让单次STW的时间最短

#### 串行（Serial）

使用串行垃圾回收器的代码：

![image-20210316211933373](https://i.loli.net/2021/03/16/lyASZK8DYsRVeoW.png)

在VM Options中设置的参数。前者Serial使用的是复制算法的新生代区，后者SerialOld表示的是老年代，使用的是标记整理算法。

因为串行回收器是单线程的，所以在使用串行回收器的时候，需要将其他的线程阻塞，只留下串行垃圾回收器线程在运行，确保垃圾回收的安全可靠。

![image-20210316212216311](https://i.loli.net/2021/03/16/yQjB15XegkuTACs.png)

#### 吞吐量优先（Parallel）

使用吞吐量优先垃圾回收器，需要设置的参数如下：

其中，第一行的两个参数，在jdk1.8中是默认打开的。最后一个参数是控制GC的线程数。

第二行表示的采用一个大小自适应的策略，调整的是新生代的大小。第三行：GC时间比率；第四行：最大GC暂停耗时。

| 英文     | 中文                         |
| -------- | ---------------------------- |
| Parallel | 平行的; 同时发生的;  并行的; |
| Ratio    | 比率; 比例;                  |
| Millis   | 耗时                         |

![image-20210316212544222](https://i.loli.net/2021/03/16/e2MN5Fxqn8IsWab.png)

由于吞吐量优先的垃圾回收器算法是多线程的，所以在进行垃圾回收的时候，同时运行多个垃圾回收线程（一般线程数等于处理器核心数），降低单位内的STW时间。

![image-20210316213611886](https://i.loli.net/2021/03/16/W9JhHG1ungo3IaC.png)

#### 响应时间优先

![image-20210320160533454](https://i.loli.net/2021/03/20/7mhwSTtygCzcYUa.png)

第一个参数，UseConcMarkSweepGC——Concurrent，并发；意即”使用并发标记清除GC算法“。

第二行第二个参数，并发GC线程数，一般设置的线程数为CPU核心数的四分之一。如四核CPU需要使用三个核心留给用户线程，留下一个核心处理垃圾回收。这样就使得原来的用户线程只能使用四分之三的CPU线程，这样会对整个用户程序的吞吐量造成影响。

响应时间优先的垃圾回收中，由于是并发执行的垃圾回收，当垃圾回收时，其他的四分之三的用户线程在执行的时候，也会产生一定量的垃圾，这些垃圾我们叫做浮动垃圾，但是由于并发执行，这个时候浮动垃圾只能留到下一次的垃圾回收再进行清理。由于不像之前的垃圾回收一样是等到堆内存不足再进行垃圾回收，这个时候如果浮动垃圾产生导致堆内存空间不足，则会使得空间不足的情况产生，所以在垃圾回收之前还需要预留一些空间。

此时，第三行的参数则是设置这一预留的垃圾空间占比。比如设置80%，则当堆内存空间占用达到80%的时候，就会开始进行垃圾回收，预留20%的空间留给浮动垃圾。这一参数的缺省值在65%左右，如果这一参数设置的越小，那么CMS进行的时间就要越早。

第四行的参数是留给重新标记之前扫面新生代的垃圾，可以避免一些不需要的重复扫描。

CMS垃圾回收存在一些弊端：当新生代中内存碎片过多时，可能导致并发失败，退化成SerialOld。

#### G1垃圾回收器（Garbage First）

![image-20210320174010992](https://gitee.com/realBeBetter/image/raw/master/img/AML47OtXU1Wpi3R.png)

根据介绍可知，在jdk9中，已经默认使用G1垃圾回收器了，废弃了之前使用的CMS响应时间优先垃圾回收器。G1和CMS同属于并发的垃圾回收器，两者在堆内存空间小的情况下，暂停的时间几乎一致；但是若是堆空间超大的堆内存，则G1的垃圾回收时间更短。

第一个参数是打开G1的使用开关，在jdk9以及之后的版本则不需要使用这一参数了，因为是默认打开的。

其中，第二个参数的使用，size大小必须设置成1、2、4、8……这样的数字大小。

##### G1垃圾回收阶段

![image-20210320175436971](https://gitee.com/realBeBetter/image/raw/master/img/m76MPWK4NVYfDAy.png)

在G1回收器中，以上三个阶段是一个循环的过程。从新生代收集开始，之后进入新生代的收集和并发标记阶段，再进入混合收集阶段，这一阶段同时回收新生代和老年的垃圾。

##### Young Collection

因为G1在使用的时候会将堆内存划分成一个个的Region区域，每一个区域都可以看作包含有老年代与包含Eden伊甸园、幸存区from、幸存区To的新生代。此阶段新生代的垃圾回收跟此前的垃圾回收一样，都会触发一次STW。![image-20210320180213997](https://i.loli.net/2021/03/20/vGUrh8MiOcgNbwK.png)

一段时间之后，会将新生代中的幸存对象通过复制算法复制到幸存区。

![image-20210320180635421](https://i.loli.net/2021/03/20/goGEeyNQ5Xi8qtx.png)

此后，在经历多轮的新生代垃圾回收之后，有一部分的幸存对象会晋升到老年区。

![image-20210320180743628](https://i.loli.net/2021/03/20/3g7yPWw4Dj9HCIF.png)

##### Young Collection + Concurrent Mark

![image-20210320180848396](https://i.loli.net/2021/03/20/82EZoi65ycgIvze.png)

这个阶段相比于前一个Young Collection阶段多了个并发标记。当前一阶段的Serial幸存区对象晋升到老年代中，这个时候老年代内存空间开始累积。当老年代占用堆空间比例达到阈值时，开始进行并发标记（由于是并发标记，不会STW，参考之前的CMS），阈值可以由图中的参数决定。

##### Mixed Collection

混合收集会对Eden伊甸园、Serial幸存区、Old老年区进行全面的垃圾回收。由于之前提到的最大暂停耗时缺省值是200ms，由于G1的使用场景复杂，为了达到最大暂停耗时的目标（不超出这个最大暂停耗时），使用复制算法的时候需要复制的对象过多时，这个时候就需要G1判断回收最有回收价值的老年区对象（意即回收之后能够获得更多的空闲空间——垃圾最多的区域——以及是否能够进行回收）。

此阶段的垃圾收集存在一个最终标记过程，由于之前在进行并发标记的时候，用户线程在使用，可能产生新的一写浮动垃圾或者改变对象的引用关系，这个时候垃圾回收的效果会受到影响，所以在进行最终标记的时候会出现STW。拷贝存货时候，会回收那些垃圾最多的老年代区域。

![image-20210320181519023](https://i.loli.net/2021/03/20/LNR3rE7HjVmbfxq.png)

##### Full GC

之前使用的垃圾回收器一共有四种：串行垃圾回收器——Serial GC；并行垃圾回收器——Parallel GC；相应时间优先——CMS；Garbage First垃圾回收器。但是只有在串行和并行的垃圾回收时，老年代空间不足触发的垃圾回收才能叫做full GC。

在G1垃圾回收中，当老年代内存空间占比达到阈值（默认时45%），会进入到一个并发标记的阶段以及混合收集的阶段。

①当垃圾回收的速度大于用户线程产生的垃圾速度（只有在最终标记才会STW，而且这个STW时间非常短），这个时候触发的垃圾回收不叫full GC

②当垃圾回收的速度跟不上用户的垃圾产生速度了，这个时候并发收集就会失败，最终导致垃圾回收退化成Serial GC，触发Full GC

在CMS垃圾回收中，当并发失败了，才会进行Full GC。这个阶段，可以根据GC日志中的打印内容判断是否进行了一次Full GC。

**GC分类**

- SerialGC
  - 新生代内存不足发生的垃圾收集：minor gc
  - 老年代内存不足发生的垃圾收集：full gc
- ParallelGC
  - 新生代内存不足发生的垃圾收集：minor gc
  - 老年代内存不足发生的垃圾收集：full gc
- CMS
  - 新生代内存不足发生的垃圾收集：minor gc
  - 老年代内存不足
- G1
  - 新生代内存不足发生的垃圾收集：minor gc
  - 老年代内存不足

##### Young Collection跨代引用

在新生代的垃圾回收中，整个过程是：①对新生代中的对象进行扫描，确定GC Root对象；②进行可达性分析，确定垃圾回收的对象和存活对象；③将存活对象复制到幸存区To；这一阶段，当From中存在的对象，会根据生命周期以及存活是否判断，是进行回收还是晋升到老年区中，没有达到阈值但是仍然存活的对象会被复制到To中。

> 幸存区中有两个区域，分别为From和To，比例为8：1
>
> HotSpot默认Eden与Survivor的大小比例是8 : 1，也就是说Eden : Survivor From : Survivor To = 8:1:1。所以每次新生代可用内存空间为整个新生代容量的90%，而剩下的10%用来存放回收后存活的对象。
>
> 因为新生代中的对象大多是”朝生夕死“的，存活周期很短，只有非常少的对象才会需要长时间使用。

经过这一次的Minor GC之后，From的空间会被全部清空，这个时候就会交换From区域和To区域。这个时候Minor GC已经基本完成。在进行下一次的Minor GC之前（也就是GC刚开始的时候），幸存区To的空间是空的，因为要将Eden中的对象和From区域的对象进行复制到To区域。

![image-20210320185148752](https://i.loli.net/2021/03/20/u3jLkURM1GnHhPX.png)

整个过程中，那么在寻找GC Root对象的时候，就会产生问题：GC Root中有一些对象是老年区的，老年代引用新生代中的对象时，需要怎么处理呢？这个时候如果遍历整个老年代的话，会产生非常高的消耗。这个时候我们采取”卡（card）表（table）“的方式，将老年代区域划分成多个细块——卡。其中有引用新生代对象的卡，称之为”脏卡“。脏卡引用的新生代对象是不能够被直接垃圾回收的。

![image-20210320185943338](https://i.loli.net/2021/03/20/ADIjBlXvFGaq5kQ.png)

##### Remark

![image-20210320190858047](https://i.loli.net/2021/03/20/CMTzdANHagx9UR1.png)

其中，黑色表示已经处理完成的；灰色表示尚在处理当中的；白色表示尚未处理的。此图中，当灰色的处理完成，因为强引用（直线箭头），灰色最终会变成黑色；而连接着灰色的白色最终也会变成黑色。独立的白色最终会被当成垃圾进行回收。

但是在实际的垃圾回收中，情况往往更加复杂。当对象的引用在标记进行的时候发生改变，原本可能可以回收的却不能被回收，但是在标记之后仍为“白色”状态，这个时候就不能对这个对象进行垃圾回收，但是标记的状态却没被更改，如何处理？

这个过程的实际处理中，JVM加入了一种写屏障——`pre-write-barrier`。当该对象的引用关系发生改变，写屏障就会得知状态改变，而将该对象加入到一个特定的队列（`stab_mark_queue`）中。

在原本的处理中，下列的对象的处理中，将C对象（原本是白色状态）转变为处理中的状态（灰色）。这个时候就会进入重新标记的状态，重新标记会发生STW，并将队列中的对象重新取出来做检查

![image-20210320191845723](https://i.loli.net/2021/03/20/XsITNdcrGAwxMvU.png)

##### JDK 8u20 字符串去重

这个字符串去重开关为默认开启的。具体开启方法参看下图中的开启参数。因为该过程发生于新生代的垃圾回收，所以占用更多的CPU时间，但是相比于带来的内存空间收益，这个时间上的些微更多的花费更加划算。

![image-20210320192316973](https://i.loli.net/2021/03/20/BCF79viONzt5auP.png)

##### JDK 8u40 并发标记类卸载

所有对象都经过并发标记后，就能知道哪些类不再被使用。当一个类加载器的所有类都不再被使用，就卸载它所加载的所有类，此功能默认开启。

```
-Xx:+ClassUnloadingWithConcurrentMark
```

##### JDK 8u60 回收巨型对象

![image-20210320193323477](https://i.loli.net/2021/03/20/ENqOvdiAl1fMKs9.png)

巨型对象的内存占用情况，是指占用的区域超过region的一半。

当老年代中的卡表对于巨型对象的引用变为0的时候，巨型对象在新生代的时候就能够被垃圾回收。

根据内存占用情况以及垃圾回收所得的效益来看，垃圾回收的时候会优先回收掉巨型对象。

![image-20210323092253901](https://i.loli.net/2021/03/23/3Sro61R7lTvUkaQ.png)

##### JDK 9并发标记起始时间调整

![image-20210323092652056](https://i.loli.net/2021/03/23/6mSEIvAspMk2rjQ.png)

根据之前的G1回收的情况，G1在垃圾回收时会经历三个阶段：Young Collection、Young Collection+CM、Mixed Collection。这个时候由第一个阶段进入到第二个阶段，开始并发标记，这个阶段会产生一个阈值（即何时开始进行并发标记）。这个时候可以通过调整上述的参数得以调整堆内存的占比设定开始并发标记的时机，此参数的缺省值是45%。而在jdk 9的版本中，该值可以动态调整以达到最好的效果。

- 如果参数过大，会导致退化成Full GC
- 如果参数过小，会导致频繁进行并发标记，降低效率

##### JDK 9更高效的回收

![image-20210323093603173](https://i.loli.net/2021/03/23/H8C6edDUMK19whL.png)

### 垃圾回收调优

![image-20210323094402175](https://i.loli.net/2021/03/23/CWhaHGIMnPldmJe.png)

#### 调优领域

调优领域一般包括：内存、锁竞争、CPU占用、IO

#### 确定目标

根据具体的需求，确定调优的目标。第二行的垃圾回收器针对的是低延迟、快速响应；第三行的垃圾回收器是针对高吞吐量。

其中，ZGC是jdk 12中的一个尚处于体验阶段的GC。此外还有`Zing`垃圾回收器，没有STW时间。

最后，如果发现没有合适的垃圾回收器选项，可以选择HotSpot之外的其他虚拟机的垃圾回收器。

![image-20210323095200429](https://i.loli.net/2021/03/23/FwvKHSN1ztslDJC.png)

#### 最快的GC是不发生GC

![image-20210323100108032](https://i.loli.net/2021/03/23/FEDkYBR2AVGKbnl.png)

#### 新生代调优

![image-20210323100922518](https://i.loli.net/2021/03/23/Dsb7JRvhVyHcCEF.png)

以上的特点，说明了新生代优化空间大。在实际情况中，我们一般通过预设新生代的堆内存大小（预设堆内存），达到调优新生代的目的。

![image-20210323101252815](https://i.loli.net/2021/03/23/fh9QbgYeyFlWZJV.png)

根据Oracle的官方建议，新生代的内存预设最好控制在整个堆内存的25%-50%之间。

吞吐量和新生代空间大小的关系大致如下所示：

![image-20210323101805081](https://i.loli.net/2021/03/23/DlgJaposOxACTVd.png)

新生代需要能容纳所有【并发量*（请求-响应）】的数据。其中，新生代中的幸存区需要能满足保留【当前活跃对象+需要晋升对象】的空间大小。

![image-20210323102852967](https://i.loli.net/2021/03/23/Za8AQCFixsb7Y5G.png)

其中，第一个参数是设置新生代晋升为老年代的阈值；第二个参数是打印相关的参数信息，参数信息例如存活周期、内存大小、总内存。

#### 老年代调优

![image-20210323103124919](https://i.loli.net/2021/03/23/xsRLpAX6StBhkHM.png)

#### 案例

根据调优相关的问题，分析几个案例。

![image-20210323103518854](https://i.loli.net/2021/03/23/EKoWZlG5RerLwac.png)

这些案例中，需要先了解到GC过程中的一些流程。

> 初始标记：仅仅标记GC Roots的直接关联对象，并触发STW
>
> 并发标记：使用GC Roots Tracing算法，进行跟踪标记，不触发STW
>
> 重新标记：因为并发标记的缘故，其他用户线程不暂停，可能产生浮动垃圾，所以这一阶段产生STW

案例三中，JDK1.7版本使用的是元空间以及永久代，当元空间不足的时候，就会触发一次Full GC。解决方案就是增大元空间的初始值和最大值。
